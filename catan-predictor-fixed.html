<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Catan Win Predictor - Bug Fixed</title>
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        .hex-tile {
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .hex-tile:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }
        
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        .simulation-running {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .result-card {
            transition: all 0.3s ease;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        // Fixed Game Types and Constants
        const RESOURCES = ["wood", "brick", "sheep", "wheat", "ore"];
        const TOKENS = [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12];
        const PLAYER_COLORS = ["#e74c3c", "#3498db", "#2ecc71", "#f1c40f"];

        // Enhanced Prediction System with Bug Fixes
        class EnhancedPredictionSystem {
            constructor() {
                this.isRunning = false;
            }

            async predictWinner(boardSetup, startingPositions, simulationCount = 1000, options = {}) {
                this.isRunning = true;
                console.log(`🎯 Starting ${simulationCount} simulations...`);
                
                const results = {
                    wins: Array(4).fill(0),
                    totalGames: simulationCount,
                    averageGameLength: 0,
                    playerStats: Array(4).fill(null).map((_, i) => ({
                        playerId: i,
                        wins: 0,
                        winPercentage: 0,
                        averageVP: 0,
                        averageResources: 0
                    })),
                    convergenceData: []
                };

                let totalGameLength = 0;
                const batchSize = 50;

                for (let batch = 0; batch < Math.ceil(simulationCount / batchSize); batch++) {
                    if (!this.isRunning) break;
                    
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min((batch + 1) * batchSize, simulationCount);
                    
                    // Simulate batch
                    for (let i = batchStart; i < batchEnd; i++) {
                        if (!this.isRunning) break;
                        
                        const gameResult = this.simulateGame(boardSetup, startingPositions);
                        if (gameResult) {
                            results.wins[gameResult.winnerId]++;
                            totalGameLength += gameResult.gameLength;
                            
                            // Update player stats
                            gameResult.playerStats.forEach((playerStat, playerId) => {
                                const stats = results.playerStats[playerId];
                                stats.averageVP += playerStat.victoryPoints;
                                stats.averageResources += playerStat.totalResources;
                            });
                        }
                        
                        // Progress callback - Fixed: throttled updates
                        if (options.onProgress && (i + 1) % 50 === 0) {
                            options.onProgress(i + 1, simulationCount);
                        }
                        
                        // Track convergence every 100 games
                        if ((i + 1) % 100 === 0) {
                            results.convergenceData.push({
                                gameNumber: i + 1,
                                winRates: results.wins.map(w => w / (i + 1)),
                                confidence: this.calculateConfidenceInterval(results.wins, i + 1)
                            });
                        }
                    }
                    
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Calculate final statistics
                if (this.isRunning && results.wins.reduce((a, b) => a + b, 0) > 0) {
                    results.averageGameLength = totalGameLength / Math.max(1, results.wins.reduce((a, b) => a + b, 0));
                    
                    results.playerStats.forEach((stats, playerId) => {
                        stats.wins = results.wins[playerId];
                        stats.winPercentage = (results.wins[playerId] / simulationCount) * 100;
                        stats.averageVP /= Math.max(1, results.wins.reduce((a, b) => a + b, 0));
                        stats.averageResources /= Math.max(1, results.wins.reduce((a, b) => a + b, 0));
                    });

                    results.confidenceIntervals = results.wins.map(wins => 
                        this.calculateConfidenceInterval([wins], simulationCount)
                    );
                }

                this.isRunning = false;
                console.log(`✅ Completed ${simulationCount} simulations`);
                return results;
            }

            simulateGame(boardSetup, startingPositions) {
                try {
                    // Enhanced simulation with proper board consideration
                    const playerProduction = this.calculatePlayerProduction(boardSetup, startingPositions);
                    const gameLength = Math.floor(Math.random() * 50) + 30; // 30-80 turns
                    
                    // More realistic game simulation
                    const finalVP = playerProduction.map((prod, playerId) => {
                        const baseVP = 2; // Starting VP
                        const productionBonus = Math.min(6, prod.total * 8); // Cap bonus
                        const randomFactor = Math.random() * 2; // Reduced randomness
                        const diversityBonus = Object.values(prod.resources).filter(v => v > 0).length * 0.5;
                        
                        return Math.min(12, Math.max(2, baseVP + productionBonus + randomFactor + diversityBonus));
                    });
                    
                    const winnerId = finalVP.indexOf(Math.max(...finalVP));
                    
                    return {
                        winnerId,
                        gameLength,
                        playerStats: finalVP.map((vp, i) => ({
                            victoryPoints: vp,
                            totalResources: playerProduction[i].total * gameLength / 10,
                            settlements: Math.min(5, Math.max(2, Math.floor(vp / 2))),
                            cities: Math.min(4, Math.max(0, Math.floor((vp - 2) / 2))),
                            roads: Math.min(15, Math.max(2, Math.floor(vp * 1.5)))
                        }))
                    };
                } catch (error) {
                    console.error('Simulation error:', error);
                    return null;
                }
            }

            calculatePlayerProduction(boardSetup, startingPositions) {
                // Enhanced production calculation considering actual board
                const diceProbs = {
                    2: 1/36, 3: 2/36, 4: 3/36, 5: 4/36, 6: 5/36,
                    8: 5/36, 9: 4/36, 10: 3/36, 11: 2/36, 12: 1/36
                };
                
                return Array(4).fill(null).map((_, playerId) => {
                    let totalProduction = 0;
                    const resources = { wood: 0, brick: 0, sheep: 0, wheat: 0, ore: 0 };
                    
                    // Simulate 2 starting settlements with better placement logic
                    const availableTiles = boardSetup.tiles.filter(tile => 
                        tile.resource !== 'desert' && tile.token
                    );
                    
                    // Choose 4-6 best tiles for settlements (overlapping adjacency)
                    const chosenTiles = availableTiles
                        .sort((a, b) => {
                            const aValue = (diceProbs[a.token] || 0) * this.getResourceValue(a.resource);
                            const bValue = (diceProbs[b.token] || 0) * this.getResourceValue(b.resource);
                            return bValue - aValue;
                        })
                        .slice(0, Math.min(6, availableTiles.length));
                    
                    chosenTiles.forEach(tile => {
                        const production = (diceProbs[tile.token] || 0) * this.getResourceValue(tile.resource);
                        totalProduction += production;
                        resources[tile.resource] += production;
                    });
                    
                    return { total: totalProduction, resources };
                });
            }

            getResourceValue(resource) {
                const values = { wood: 1, brick: 1, sheep: 1, wheat: 1.1, ore: 1.2 };
                return values[resource] || 1;
            }

            calculateConfidenceInterval(wins, totalGames, confidence = 0.95) {
                const z = confidence === 0.95 ? 1.96 : 2.576;
                
                return wins.map(w => {
                    if (totalGames === 0) return [0, 0];
                    
                    const p = w / totalGames;
                    const n = totalGames;
                    
                    if (n === 0 || p === 0 || p === 1) {
                        return [0, 1];
                    }
                    
                    const denominator = 1 + (z * z) / n;
                    const center = (p + (z * z) / (2 * n)) / denominator;
                    const margin = (z / denominator) * Math.sqrt((p * (1 - p)) / n + (z * z) / (4 * n * n));
                    
                    return [
                        Math.max(0, center - margin),
                        Math.min(1, center + margin)
                    ];
                });
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Fixed Main Prediction App Component
        function CatanPredictor() {
            const [predictionSystem] = React.useState(() => new EnhancedPredictionSystem());
            const [boardSetup, setBoardSetup] = React.useState(createRandomBoard());
            const [simulationCount, setSimulationCount] = React.useState(1000);
            const [isRunning, setIsRunning] = React.useState(false);
            const [progress, setProgress] = React.useState(0);
            const [results, setResults] = React.useState(null);
            const [selectedTile, setSelectedTile] = React.useState(null);

            const runPrediction = async () => {
                setIsRunning(true);
                setProgress(0);
                setResults(null);
                
                try {
                    const predictionResults = await predictionSystem.predictWinner(
                        boardSetup, 
                        null,
                        simulationCount,
                        {
                            onProgress: (current, total) => {
                                setProgress((current / total) * 100);
                            }
                        }
                    );
                    
                    setResults(predictionResults);
                } catch (error) {
                    console.error('Prediction failed:', error);
                    alert('Prediction failed: ' + error.message);
                } finally {
                    setIsRunning(false);
                    setProgress(0);
                }
            };

            const stopPrediction = () => {
                predictionSystem.stop();
                setIsRunning(false);
                setProgress(0);
            };

            const resetBoard = () => {
                setBoardSetup(createRandomBoard());
                setResults(null);
                setSelectedTile(null);
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-green-50">
                    {/* Header */}
                    <header className="bg-white shadow-lg border-b-4 border-amber-500">
                        <div className="max-w-7xl mx-auto px-4 py-4">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center space-x-4">
                                    <h1 className="text-3xl font-bold text-gray-800">🎯 Advanced Catan Win Predictor</h1>
                                    <div className="text-sm text-gray-600">
                                        Bug Fixed Version - Enhanced Simulation Engine
                                    </div>
                                </div>
                                <div className="flex items-center space-x-4">
                                    <button 
                                        onClick={resetBoard}
                                        disabled={isRunning}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 text-white rounded-lg font-medium"
                                    >
                                        🎲 New Random Board
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    <div className="max-w-7xl mx-auto px-4 py-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                        
                        {/* Board Visualization */}
                        <div className="lg:col-span-2">
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <h2 className="text-xl font-bold mb-4">Game Board</h2>
                                <BoardVisualization 
                                    boardSetup={boardSetup}
                                    onTileClick={setSelectedTile}
                                    selectedTile={selectedTile}
                                />
                            </div>
                        </div>

                        {/* Control Panel */}
                        <div className="space-y-6">
                            
                            {/* Simulation Controls */}
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <h3 className="text-lg font-bold mb-4">Simulation Controls</h3>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Number of Simulations
                                        </label>
                                        <select 
                                            value={simulationCount}
                                            onChange={(e) => setSimulationCount(Number(e.target.value))}
                                            disabled={isRunning}
                                            className="w-full border border-gray-300 rounded-lg px-3 py-2 disabled:bg-gray-100"
                                        >
                                            <option value={100}>100 (Fast)</option>
                                            <option value={500}>500 (Good)</option>
                                            <option value={1000}>1,000 (Accurate)</option>
                                            <option value={2000}>2,000 (Very Accurate)</option>
                                            <option value={5000}>5,000 (Maximum)</option>
                                        </select>
                                    </div>
                                    
                                    {isRunning ? (
                                        <div className="space-y-3">
                                            <div className="flex items-center justify-between">
                                                <span className="text-sm font-medium text-gray-700">Progress</span>
                                                <span className="text-sm text-gray-600">{progress.toFixed(1)}%</span>
                                            </div>
                                            <div className="w-full bg-gray-200 rounded-full h-3">
                                                <div 
                                                    className="progress-bar bg-blue-500 h-3 rounded-full simulation-running"
                                                    style={{width: `${progress}%`}}
                                                />
                                            </div>
                                            <button
                                                onClick={stopPrediction}
                                                className="w-full px-4 py-3 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg"
                                            >
                                                ⏹️ Stop Simulation
                                            </button>
                                        </div>
                                    ) : (
                                        <button
                                            onClick={runPrediction}
                                            className="w-full px-4 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg"
                                        >
                                            ▶️ Run Prediction
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Tile Editor */}
                            {selectedTile !== null && (
                                <div className="bg-white rounded-xl shadow-lg p-6">
                                    <h3 className="text-lg font-bold mb-4">Edit Tile {selectedTile}</h3>
                                    <TileEditor 
                                        tile={boardSetup.tiles[selectedTile]}
                                        onUpdate={(updates) => {
                                            setBoardSetup(prev => ({
                                                ...prev,
                                                tiles: prev.tiles.map((tile, index) => 
                                                    index === selectedTile ? { ...tile, ...updates } : tile
                                                )
                                            }));
                                        }}
                                        onClose={() => setSelectedTile(null)}
                                    />
                                </div>
                            )}

                            {/* Board Statistics */}
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <h3 className="text-lg font-bold mb-4">Board Statistics</h3>
                                <BoardStats boardSetup={boardSetup} />
                            </div>

                        </div>
                    </div>

                    {/* Results Section */}
                    {results && (
                        <div className="max-w-7xl mx-auto px-4 pb-6">
                            <PredictionResults results={results} />
                        </div>
                    )}
                </div>
            );
        }

        // Fixed Board Visualization Component
        function BoardVisualization({ boardSetup, onTileClick, selectedTile }) {
            return (
                <div className="relative">
                    <svg width="600" height="500" viewBox="0 0 600 500" className="border rounded-lg bg-blue-50">
                        {/* Render tiles */}
                        {boardSetup.tiles.map((tile, index) => (
                            <HexTile 
                                key={index}
                                tile={tile}
                                index={index}
                                onClick={() => onTileClick(index)}
                                isSelected={selectedTile === index}
                            />
                        ))}
                    </svg>
                </div>
            );
        }

        // Enhanced Hex Tile Component
        function HexTile({ tile, index, onClick, isSelected }) {
            const size = 35;
            const x = tile.x;
            const y = tile.y;
            
            // Generate hex path
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                points.push([
                    x + size * Math.cos(angle),
                    y + size * Math.sin(angle)
                ]);
            }
            const path = `M ${points.map(p => p.join(',')).join(' L ')} Z`;
            
            const colors = {
                wood: "#8BC34A",
                brick: "#E57373", 
                sheep: "#AED581",
                wheat: "#FBC02D",
                ore: "#B0BEC5",
                desert: "#F5DEB3"
            };

            const isHotNumber = tile.token === 6 || tile.token === 8;

            return (
                <g className="hex-tile" onClick={onClick}>
                    <path 
                        d={path} 
                        fill={colors[tile.resource] || "#ddd"} 
                        stroke={isSelected ? "#3b82f6" : "#374151"} 
                        strokeWidth={isSelected ? "4" : "2"}
                    />
                    {tile.token && (
                        <g>
                            <circle 
                                cx={x} 
                                cy={y} 
                                r="16" 
                                fill="white" 
                                stroke={isHotNumber ? "#ef4444" : "#334155"} 
                                strokeWidth={isHotNumber ? "3" : "1.5"}
                            />
                            <text 
                                x={x} 
                                y={y + 5} 
                                textAnchor="middle" 
                                fontSize="14" 
                                fontWeight="700" 
                                fill="#111827"
                            >
                                {tile.token}
                            </text>
                        </g>
                    )}
                    <text 
                        x={x} 
                        y={y + 45} 
                        textAnchor="middle" 
                        fontSize="10" 
                        fill="#666"
                    >
                        {index}
                    </text>
                </g>
            );
        }

        // Enhanced Tile Editor Component
        function TileEditor({ tile, onUpdate, onClose }) {
            const resourceIcons = {
                wood: "🌲", brick: "🧱", sheep: "🐑", 
                wheat: "🌾", ore: "⚒️", desert: "🏜️"
            };

            return (
                <div className="space-y-4">
                    <div className="flex justify-between items-center">
                        <span className="text-sm font-medium text-gray-700">Edit Tile</span>
                        <button 
                            onClick={onClose}
                            className="text-gray-400 hover:text-gray-600"
                        >
                            ✕
                        </button>
                    </div>
                    
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Resource</label>
                        <select 
                            value={tile.resource}
                            onChange={(e) => onUpdate({ 
                                resource: e.target.value,
                                token: e.target.value === 'desert' ? null : tile.token
                            })}
                            className="w-full border border-gray-300 rounded-lg px-3 py-2"
                        >
                            {Object.entries(resourceIcons).map(([resource, icon]) => (
                                <option key={resource} value={resource}>
                                    {icon} {resource.charAt(0).toUpperCase() + resource.slice(1)}
                                </option>
                            ))}
                        </select>
                    </div>

                    {tile.resource !== 'desert' && (
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Number Token</label>
                            <select 
                                value={tile.token || ''}
                                onChange={(e) => onUpdate({ token: e.target.value ? Number(e.target.value) : null })}
                                className="w-full border border-gray-300 rounded-lg px-3 py-2"
                            >
                                <option value="">No Token</option>
                                {[2,3,4,5,6,8,9,10,11,12].map(num => (
                                    <option key={num} value={num}>
                                        {num} {num === 6 || num === 8 ? '(Hot!)' : ''}
                                    </option>
                                ))}
                            </select>
                        </div>
                    )}
                </div>
            );
        }

        // Enhanced Board Statistics Component
        function BoardStats({ boardSetup }) {
            const resourceCounts = RESOURCES.reduce((acc, resource) => {
                acc[resource] = boardSetup.tiles.filter(tile => tile.resource === resource).length;
                return acc;
            }, { desert: boardSetup.tiles.filter(tile => tile.resource === 'desert').length });

            const tokenCounts = {};
            boardSetup.tiles.forEach(tile => {
                if (tile.token) {
                    tokenCounts[tile.token] = (tokenCounts[tile.token] || 0) + 1;
                }
            });

            const totalTiles = boardSetup.tiles.length;
            const isValidBoard = totalTiles === 19 && resourceCounts.desert === 1;

            return (
                <div className="space-y-4">
                    <div className={`p-2 rounded text-sm ${isValidBoard ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                        {isValidBoard ? '✅ Valid Catan Board' : '❌ Invalid Board Layout'}
                    </div>
                    
                    <div>
                        <h4 className="font-medium text-gray-700 mb-2">Resources</h4>
                        <div className="space-y-1">
                            {Object.entries(resourceCounts).map(([resource, count]) => (
                                <div key={resource} className="flex justify-between text-sm">
                                    <span className="capitalize">{resource}</span>
                                    <span className={count === 0 ? 'text-red-500' : ''}>{count}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div>
                        <h4 className="font-medium text-gray-700 mb-2">Number Tokens</h4>
                        <div className="grid grid-cols-3 gap-1 text-xs">
                            {Object.entries(tokenCounts).sort((a, b) => Number(a[0]) - Number(b[0])).map(([token, count]) => (
                                <div key={token} className="flex justify-between">
                                    <span>{token}:</span>
                                    <span>{count}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // Fixed Prediction Results Component
        function PredictionResults({ results }) {
            // Validate results
            if (!results || !results.playerStats) {
                return (
                    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                        ❌ Invalid simulation results
                    </div>
                );
            }

            return (
                <div className="bg-white rounded-xl shadow-lg p-6">
                    <h2 className="text-2xl font-bold mb-6">🎯 Prediction Results</h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                        {results.playerStats.map((stats, index) => (
                            <div key={index} className="result-card bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg p-4">
                                <div className="flex items-center mb-2">
                                    <div 
                                        className="w-4 h-4 rounded-full mr-2" 
                                        style={{backgroundColor: PLAYER_COLORS[index]}}
                                    />
                                    <h3 className="font-bold text-lg">Player {index + 1}</h3>
                                </div>
                                
                                <div className="space-y-2">
                                    <div className="text-2xl font-bold text-green-600">
                                        {stats.winPercentage.toFixed(1)}%
                                    </div>
                                    <div className="text-sm text-gray-600">
                                        {stats.wins} / {results.totalGames} wins
                                    </div>
                                    <div className="text-xs text-gray-500">
                                        Avg VP: {stats.averageVP.toFixed(1)}
                                    </div>
                                    {results.confidenceIntervals && results.confidenceIntervals[index] && (
                                        <div className="text-xs text-gray-500">
                                            CI95: {(results.confidenceIntervals[index][0] * 100).toFixed(1)}% - {(results.confidenceIntervals[index][1] * 100).toFixed(1)}%
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        
                        {/* Win Rate Chart */}
                        <div className="bg-gray-50 rounded-lg p-4">
                            <h3 className="font-bold text-lg mb-4">Win Rate Distribution</h3>
                            <WinRateChart results={results} />
                        </div>

                        {/* Game Statistics */}
                        <div className="bg-gray-50 rounded-lg p-4">
                            <h3 className="font-bold text-lg mb-4">Game Statistics</h3>
                            <div className="space-y-3">
                                <div className="flex justify-between">
                                    <span>Total Games:</span>
                                    <span className="font-bold">{results.totalGames.toLocaleString()}</span>
                                </div>
                                <div className="flex justify-between">
                                    <span>Average Game Length:</span>
                                    <span className="font-bold">{results.averageGameLength.toFixed(1)} turns</span>
                                </div>
                                <div className="flex justify-between">
                                    <span>Most Likely Winner:</span>
                                    <span className="font-bold" style={{color: PLAYER_COLORS[results.wins.indexOf(Math.max(...results.wins))]}}>
                                        Player {results.wins.indexOf(Math.max(...results.wins)) + 1}
                                    </span>
                                </div>
                                <div className="flex justify-between">
                                    <span>Win Rate Spread:</span>
                                    <span className="font-bold">
                                        {(Math.max(...results.playerStats.map(p => p.winPercentage)) - 
                                          Math.min(...results.playerStats.map(p => p.winPercentage))).toFixed(1)}%
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Convergence Chart */}
                    {results.convergenceData && results.convergenceData.length > 0 && (
                        <div className="mt-6 bg-gray-50 rounded-lg p-4">
                            <h3 className="font-bold text-lg mb-4">Convergence Analysis</h3>
                            <ConvergenceChart data={results.convergenceData} />
                        </div>
                    )}
                </div>
            );
        }

        // Fixed Win Rate Chart Component (Memory Leak Fixed)
        function WinRateChart({ results }) {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);

            React.useEffect(() => {
                if (!canvasRef.current) return;

                // Destroy existing chart to prevent memory leaks
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                const ctx = canvasRef.current.getContext('2d');
                
                chartRef.current = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: results.playerStats.map((_, i) => `Player ${i + 1}`),
                        datasets: [{
                            data: results.playerStats.map(p => p.winPercentage),
                            backgroundColor: PLAYER_COLORS,
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });

                // Cleanup function
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [results]);

            return <canvas ref={canvasRef} height="200" />;
        }

        // Fixed Convergence Chart Component (Memory Leak Fixed)
        function ConvergenceChart({ data }) {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);

            React.useEffect(() => {
                if (!canvasRef.current) return;

                // Destroy existing chart to prevent memory leaks
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                const ctx = canvasRef.current.getContext('2d');
                
                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.map(d => d.gameNumber),
                        datasets: Array(4).fill(null).map((_, i) => ({
                            label: `Player ${i + 1}`,
                            data: data.map(d => d.winRates[i] * 100),
                            borderColor: PLAYER_COLORS[i],
                            backgroundColor: PLAYER_COLORS[i] + '20',
                            tension: 0.4
                        }))
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Win Rate (%)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Games Simulated'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });

                // Cleanup function
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [data]);

            return <canvas ref={canvasRef} height="200" />;
        }

        // Fixed helper function to create random board (Array mutation bug fixed)
        function createRandomBoard() {
            const resources = [
                ...Array(4).fill("wood"),
                ...Array(3).fill("brick"), 
                ...Array(4).fill("sheep"),
                ...Array(4).fill("wheat"),
                ...Array(3).fill("ore"),
                "desert"
            ];
            
            const tokens = [...TOKENS];
            
            // Fixed: Create new arrays before sorting to avoid mutation
            const shuffledResources = [...resources].sort(() => Math.random() - 0.5);
            const shuffledTokens = [...tokens].sort(() => Math.random() - 0.5);
            
            const positions = [
                // Row 1
                { x: 300, y: 150 }, { x: 370, y: 150 }, { x: 440, y: 150 },
                // Row 2
                { x: 230, y: 210 }, { x: 300, y: 210 }, { x: 370, y: 210 }, { x: 440, y: 210 },
                // Row 3
                { x: 160, y: 270 }, { x: 230, y: 270 }, { x: 300, y: 270 }, { x: 370, y: 270 }, { x: 440, y: 270 },
                // Row 4
                { x: 160, y: 330 }, { x: 230, y: 330 }, { x: 300, y: 330 }, { x: 370, y: 330 },
                // Row 5
                { x: 160, y: 390 }, { x: 230, y: 390 }, { x: 300, y: 390 }
            ];
            
            const tiles = positions.map((pos, index) => {
                const resource = shuffledResources[index];
                const token = resource === 'desert' ? null : shuffledTokens.pop();
                return {
                    ...pos,
                    resource,
                    token
                };
            });
            
            return { tiles };
        }

        // Fixed: Use React 18 createRoot instead of deprecated render
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CatanPredictor />);
    </script>
</body>
</html>
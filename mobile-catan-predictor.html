<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Catan Win Predictor</title>
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        .hex-tile {
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .hex-tile:hover {
            filter: brightness(1.1);
            transform: scale(1.02);
        }
        
        .progress-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .port-indicator {
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        // Game Constants
        const RESOURCES = ["wood", "brick", "sheep", "wheat", "ore"];
        const TOKENS = [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12];
        const PLAYER_COLORS = ["#ef4444", "#3b82f6", "#10b981", "#f59e0b"];
        
        // Trading System
        const TRADING_RATIOS = {
            BANK: 4,
            GENERIC_PORT: 3,
            SPECIALIZED_PORT: 2
        };

        const PORT_TYPES = {
            GENERIC: 'generic',
            WOOD: 'wood',
            BRICK: 'brick', 
            SHEEP: 'sheep',
            WHEAT: 'wheat',
            ORE: 'ore'
        };

        // Standard port configuration
        const STANDARD_PORTS = [
            { type: PORT_TYPES.GENERIC, tiles: [0, 1], icon: "üè™" },
            { type: PORT_TYPES.WOOD, tiles: [3, 4], icon: "üå≤" },
            { type: PORT_TYPES.BRICK, tiles: [7, 8], icon: "üß±" },
            { type: PORT_TYPES.GENERIC, tiles: [12, 13], icon: "üè™" },
            { type: PORT_TYPES.SHEEP, tiles: [16, 17], icon: "üêë" },
            { type: PORT_TYPES.GENERIC, tiles: [18, 19], icon: "üè™" },
            { type: PORT_TYPES.WHEAT, tiles: [15, 11], icon: "üåæ" },
            { type: PORT_TYPES.ORE, tiles: [6, 2], icon: "‚öíÔ∏è" },
            { type: PORT_TYPES.GENERIC, tiles: [5, 9], icon: "üè™" }
        ];

        // Enhanced Trading System
        class TradingSystem {
            constructor() {
                this.portAccess = new Map();
            }

            initializePorts(boardSetup) {
                // Add ports to board
                boardSetup.ports = STANDARD_PORTS.map((port, index) => ({
                    id: index,
                    type: port.type,
                    ratio: port.type === PORT_TYPES.GENERIC ? TRADING_RATIOS.GENERIC_PORT : TRADING_RATIOS.SPECIALIZED_PORT,
                    tiles: port.tiles,
                    icon: port.icon
                }));
                return boardSetup;
            }

            calculatePortAccess(boardSetup, playerPositions) {
                const access = new Map();
                
                // For each player, check which ports they can access
                for (let playerId = 0; playerId < 4; playerId++) {
                    const playerPorts = [];
                    
                    // Check if player has settlements near ports
                    boardSetup.ports?.forEach(port => {
                        // Simplified: assume players have access based on starting positions
                        if (Math.random() < 0.3) { // 30% chance of port access
                            playerPorts.push(port);
                        }
                    });
                    
                    access.set(playerId, playerPorts);
                }
                
                this.portAccess = access;
                return access;
            }

            getBestTradingRatio(playerId, resource) {
                const playerPorts = this.portAccess.get(playerId) || [];
                
                // Check for specialized port
                const specializedPort = playerPorts.find(port => port.type === resource);
                if (specializedPort) return TRADING_RATIOS.SPECIALIZED_PORT;
                
                // Check for generic port
                const genericPort = playerPorts.find(port => port.type === PORT_TYPES.GENERIC);
                if (genericPort) return TRADING_RATIOS.GENERIC_PORT;
                
                // Default bank trading
                return TRADING_RATIOS.BANK;
            }

            getPortAdvantage(playerId) {
                const playerPorts = this.portAccess.get(playerId) || [];
                return {
                    totalPorts: playerPorts.length,
                    genericPorts: playerPorts.filter(p => p.type === PORT_TYPES.GENERIC).length,
                    specializedPorts: playerPorts.filter(p => p.type !== PORT_TYPES.GENERIC).length,
                    tradingBonus: playerPorts.length > 0 ? 0.2 : 0
                };
            }
        }

        // Enhanced Prediction System
        class MobilePredictionSystem {
            constructor() {
                this.tradingSystem = new TradingSystem();
                this.isRunning = false;
            }

            async predictWinner(boardSetup, simulationCount = 1000, options = {}) {
                this.isRunning = true;
                console.log(`üéØ Starting prediction with ${simulationCount} simulations...`);
                
                // Initialize trading system
                boardSetup = this.tradingSystem.initializePorts(boardSetup);
                const portAccess = this.tradingSystem.calculatePortAccess(boardSetup);
                
                const results = {
                    wins: Array(4).fill(0),
                    totalGames: simulationCount,
                    averageGameLength: 0,
                    playerStats: Array(4).fill(null).map((_, i) => ({
                        playerId: i,
                        wins: 0,
                        winPercentage: 0,
                        averageVP: 0,
                        averageResources: 0,
                        portAdvantage: this.tradingSystem.getPortAdvantage(i),
                        tradingEfficiency: 0
                    })),
                    convergenceData: [],
                    tradingAnalysis: {
                        portDistribution: Array(4).fill(0),
                        tradingAdvantages: []
                    }
                };

                let totalGameLength = 0;
                const batchSize = 50;

                for (let batch = 0; batch < Math.ceil(simulationCount / batchSize); batch++) {
                    if (!this.isRunning) break;
                    
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min((batch + 1) * batchSize, simulationCount);
                    
                    for (let i = batchStart; i < batchEnd; i++) {
                        if (!this.isRunning) break;
                        
                        const gameResult = this.simulateGame(boardSetup);
                        
                        if (gameResult) {
                            results.wins[gameResult.winnerId]++;
                            totalGameLength += gameResult.gameLength;
                            
                            // Update player stats with trading analysis
                            gameResult.playerStats.forEach((playerStat, playerId) => {
                                const stats = results.playerStats[playerId];
                                stats.averageVP += playerStat.victoryPoints;
                                stats.averageResources += playerStat.totalResources;
                                stats.tradingEfficiency += playerStat.tradingEfficiency || 0;
                            });
                        }
                        
                        // Progress callback
                        if (options.onProgress && (i + 1) % 25 === 0) {
                            options.onProgress(i + 1, simulationCount);
                        }
                        
                        // Convergence tracking
                        if ((i + 1) % 100 === 0) {
                            results.convergenceData.push({
                                gameNumber: i + 1,
                                winRates: results.wins.map(w => w / (i + 1))
                            });
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 5));
                }

                // Calculate final statistics
                if (results.wins.reduce((a, b) => a + b, 0) > 0) {
                    results.averageGameLength = totalGameLength / Math.max(1, results.wins.reduce((a, b) => a + b, 0));
                    
                    results.playerStats.forEach((stats, playerId) => {
                        stats.wins = results.wins[playerId];
                        stats.winPercentage = (results.wins[playerId] / simulationCount) * 100;
                        stats.averageVP /= simulationCount;
                        stats.averageResources /= simulationCount;
                        stats.tradingEfficiency /= simulationCount;
                    });

                    // Calculate trading analysis
                    results.tradingAnalysis.portDistribution = results.playerStats.map(p => p.portAdvantage.totalPorts);
                    results.tradingAnalysis.tradingAdvantages = results.playerStats.map(p => p.tradingEfficiency);
                }

                this.isRunning = false;
                console.log(`‚úÖ Prediction completed: ${simulationCount} simulations`);
                return results;
            }

            simulateGame(boardSetup) {
                const playerProduction = this.calculatePlayerProduction(boardSetup);
                const gameLength = Math.floor(Math.random() * 50) + 30;
                
                const finalVP = playerProduction.map((prod, playerId) => {
                    const baseVP = 2;
                    const productionBonus = Math.min(6, prod.total * 8);
                    const portBonus = this.tradingSystem.getPortAdvantage(playerId).tradingBonus * 2;
                    const randomFactor = Math.random() * 2;
                    const diversityBonus = Object.values(prod.resources).filter(v => v > 0).length * 0.3;
                    
                    return Math.min(12, Math.max(2, baseVP + productionBonus + portBonus + randomFactor + diversityBonus));
                });
                
                const winnerId = finalVP.indexOf(Math.max(...finalVP));
                
                return {
                    winnerId,
                    gameLength,
                    playerStats: finalVP.map((vp, i) => ({
                        victoryPoints: vp,
                        totalResources: playerProduction[i].total * gameLength / 10,
                        tradingEfficiency: this.tradingSystem.getPortAdvantage(i).tradingBonus
                    }))
                };
            }

            calculatePlayerProduction(boardSetup) {
                const diceProbs = {
                    2: 1/36, 3: 2/36, 4: 3/36, 5: 4/36, 6: 5/36,
                    8: 5/36, 9: 4/36, 10: 3/36, 11: 2/36, 12: 1/36
                };
                
                return Array(4).fill(null).map((_, playerId) => {
                    let totalProduction = 0;
                    const resources = { wood: 0, brick: 0, sheep: 0, wheat: 0, ore: 0 };
                    
                    const availableTiles = boardSetup.tiles.filter(tile => 
                        tile.resource !== 'desert' && tile.token
                    );
                    
                    const chosenTiles = availableTiles
                        .sort((a, b) => {
                            const aValue = (diceProbs[a.token] || 0) * this.getResourceValue(a.resource);
                            const bValue = (diceProbs[b.token] || 0) * this.getResourceValue(b.resource);
                            return bValue - aValue;
                        })
                        .slice(0, Math.min(6, availableTiles.length));
                    
                    chosenTiles.forEach(tile => {
                        const production = (diceProbs[tile.token] || 0) * this.getResourceValue(tile.resource);
                        totalProduction += production;
                        resources[tile.resource] += production;
                    });
                    
                    return { total: totalProduction, resources };
                });
            }

            getResourceValue(resource) {
                const values = { wood: 1, brick: 1, sheep: 0.9, wheat: 1.1, ore: 1.2 };
                return values[resource] || 1;
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Main Mobile App Component
        function MobileCatanPredictor() {
            const [predictionSystem] = React.useState(() => new MobilePredictionSystem());
            const [boardSetup, setBoardSetup] = React.useState(createRandomBoard());
            const [simulationCount, setSimulationCount] = React.useState(1000);
            const [isRunning, setIsRunning] = React.useState(false);
            const [progress, setProgress] = React.useState(0);
            const [results, setResults] = React.useState(null);
            const [selectedTile, setSelectedTile] = React.useState(null);
            const [showAdvanced, setShowAdvanced] = React.useState(false);
            const [showPorts, setShowPorts] = React.useState(false);

            const runPrediction = async () => {
                setIsRunning(true);
                setProgress(0);
                setResults(null);
                
                try {
                    const predictionResults = await predictionSystem.predictWinner(
                        boardSetup,
                        simulationCount,
                        {
                            onProgress: (current, total) => {
                                setProgress((current / total) * 100);
                            }
                        }
                    );
                    
                    setResults(predictionResults);
                } catch (error) {
                    console.error('Prediction failed:', error);
                    alert('Prediction failed: ' + error.message);
                } finally {
                    setIsRunning(false);
                    setProgress(0);
                }
            };

            const stopPrediction = () => {
                predictionSystem.stop();
                setIsRunning(false);
                setProgress(0);
            };

            const resetBoard = () => {
                setBoardSetup(createRandomBoard());
                setResults(null);
                setSelectedTile(null);
            };

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Clean Mobile Header */}
                    <header className="bg-white shadow-sm border-b">
                        <div className="px-4 py-3">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-xl font-bold text-gray-900">üéØ Catan Predictor</h1>
                                    <p className="text-sm text-gray-500">AI-powered win prediction</p>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <button 
                                        onClick={() => setShowPorts(!showPorts)}
                                        className={`px-3 py-1 text-sm rounded-full ${showPorts ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600'}`}
                                    >
                                        üè™ Ports
                                    </button>
                                    <button 
                                        onClick={() => setShowAdvanced(!showAdvanced)}
                                        className={`px-3 py-1 text-sm rounded-full ${showAdvanced ? 'bg-purple-100 text-purple-700' : 'bg-gray-100 text-gray-600'}`}
                                    >
                                        üìä Advanced
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    <div className="p-4 space-y-4">
                        
                        {/* Board Section */}
                        <div className="bg-white rounded-lg shadow-sm p-4">
                            <div className="flex items-center justify-between mb-3">
                                <h2 className="font-semibold text-gray-900">Game Board</h2>
                                <button 
                                    onClick={resetBoard}
                                    disabled={isRunning}
                                    className="px-3 py-1 bg-gray-100 hover:bg-gray-200 disabled:opacity-50 text-gray-700 text-sm rounded-md"
                                >
                                    üé≤ New Board
                                </button>
                            </div>
                            <MobileBoardVisualization 
                                boardSetup={boardSetup}
                                onTileClick={setSelectedTile}
                                selectedTile={selectedTile}
                                showPorts={showPorts}
                            />
                        </div>

                        {/* Simulation Controls */}
                        <div className="bg-white rounded-lg shadow-sm p-4">
                            <h3 className="font-semibold text-gray-900 mb-3">Prediction Settings</h3>
                            
                            <div className="space-y-3">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Simulations: {simulationCount.toLocaleString()}
                                    </label>
                                    <input
                                        type="range"
                                        min="100"
                                        max="5000"
                                        step="100"
                                        value={simulationCount}
                                        onChange={(e) => setSimulationCount(Number(e.target.value))}
                                        disabled={isRunning}
                                        className="w-full"
                                    />
                                    <div className="flex justify-between text-xs text-gray-500 mt-1">
                                        <span>100 (Fast)</span>
                                        <span>5,000 (Accurate)</span>
                                    </div>
                                </div>
                                
                                {isRunning ? (
                                    <div className="space-y-3">
                                        <div className="flex items-center justify-between text-sm">
                                            <span className="text-gray-600">Running prediction...</span>
                                            <span className="font-medium">{progress.toFixed(1)}%</span>
                                        </div>
                                        <div className="w-full bg-gray-200 rounded-full h-2">
                                            <div 
                                                className="progress-animation bg-blue-500 h-2 rounded-full transition-all duration-300"
                                                style={{width: `${progress}%`}}
                                            />
                                        </div>
                                        <button
                                            onClick={stopPrediction}
                                            className="w-full px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-medium rounded-lg"
                                        >
                                            ‚èπÔ∏è Stop
                                        </button>
                                    </div>
                                ) : (
                                    <button
                                        onClick={runPrediction}
                                        className="w-full px-4 py-3 bg-blue-500 hover:bg-blue-600 text-white font-medium rounded-lg"
                                    >
                                        ‚ñ∂Ô∏è Run Prediction
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* Tile Editor */}
                        {selectedTile !== null && (
                            <div className="slide-in bg-white rounded-lg shadow-sm p-4">
                                <MobileTileEditor 
                                    tile={boardSetup.tiles[selectedTile]}
                                    tileIndex={selectedTile}
                                    onUpdate={(updates) => {
                                        setBoardSetup(prev => ({
                                            ...prev,
                                            tiles: prev.tiles.map((tile, index) => 
                                                index === selectedTile ? { ...tile, ...updates } : tile
                                            )
                                        }));
                                    }}
                                    onClose={() => setSelectedTile(null)}
                                />
                            </div>
                        )}

                        {/* Results Section */}
                        {results && (
                            <MobilePredictionResults 
                                results={results} 
                                showAdvanced={showAdvanced}
                            />
                        )}

                        {/* Board Stats (Advanced View) */}
                        {showAdvanced && (
                            <div className="slide-in bg-white rounded-lg shadow-sm p-4">
                                <h3 className="font-semibold text-gray-900 mb-3">üìä Board Analysis</h3>
                                <MobileBoardStats boardSetup={boardSetup} />
                            </div>
                        )}

                        {/* Trading Analysis (Advanced View) */}
                        {showAdvanced && results && (
                            <div className="slide-in bg-white rounded-lg shadow-sm p-4">
                                <h3 className="font-semibold text-gray-900 mb-3">üè™ Trading Analysis</h3>
                                <MobileTradingAnalysis results={results} />
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Mobile Board Visualization
        function MobileBoardVisualization({ boardSetup, onTileClick, selectedTile, showPorts }) {
            return (
                <div className="relative">
                    <svg 
                        width="100%" 
                        height="300" 
                        viewBox="0 0 600 400" 
                        className="border rounded-lg bg-gradient-to-br from-blue-50 to-green-50"
                    >
                        {/* Render tiles */}
                        {boardSetup.tiles.map((tile, index) => (
                            <MobileHexTile 
                                key={index}
                                tile={tile}
                                index={index}
                                onClick={() => onTileClick(index)}
                                isSelected={selectedTile === index}
                            />
                        ))}
                        
                        {/* Render ports if enabled */}
                        {showPorts && boardSetup.ports && boardSetup.ports.map((port, index) => (
                            <g key={`port_${index}`}>
                                <circle 
                                    cx={50 + (index % 6) * 90} 
                                    cy={50 + Math.floor(index / 6) * 60} 
                                    r="15" 
                                    fill="white" 
                                    stroke="#4f46e5" 
                                    strokeWidth="2"
                                />
                                <text 
                                    x={50 + (index % 6) * 90} 
                                    y={55 + Math.floor(index / 6) * 60} 
                                    textAnchor="middle" 
                                    fontSize="12"
                                >
                                    {port.icon}
                                </text>
                                <text 
                                    x={50 + (index % 6) * 90} 
                                    y={70 + Math.floor(index / 6) * 60} 
                                    textAnchor="middle" 
                                    fontSize="8" 
                                    fill="#4f46e5"
                                    className="port-indicator"
                                >
                                    {port.ratio}:1
                                </text>
                            </g>
                        ))}
                    </svg>
                </div>
            );
        }

        // Mobile Hex Tile
        function MobileHexTile({ tile, index, onClick, isSelected }) {
            const size = 25;
            const x = tile.x * 0.7; // Scale down for mobile
            const y = tile.y * 0.7;
            
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                points.push([
                    x + size * Math.cos(angle),
                    y + size * Math.sin(angle)
                ]);
            }
            const path = `M ${points.map(p => p.join(',')).join(' L ')} Z`;
            
            const colors = {
                wood: "#22c55e",
                brick: "#dc2626", 
                sheep: "#84cc16",
                wheat: "#eab308",
                ore: "#6b7280",
                desert: "#f59e0b"
            };

            const isHotNumber = tile.token === 6 || tile.token === 8;

            return (
                <g className="hex-tile" onClick={onClick}>
                    <path 
                        d={path} 
                        fill={colors[tile.resource] || "#ddd"} 
                        stroke={isSelected ? "#3b82f6" : "#374151"} 
                        strokeWidth={isSelected ? "3" : "1"}
                        opacity="0.9"
                    />
                    {tile.token && (
                        <g>
                            <circle 
                                cx={x} 
                                cy={y} 
                                r="12" 
                                fill="white" 
                                stroke={isHotNumber ? "#dc2626" : "#374151"} 
                                strokeWidth={isHotNumber ? "2" : "1"}
                            />
                            <text 
                                x={x} 
                                y={y + 3} 
                                textAnchor="middle" 
                                fontSize="10" 
                                fontWeight="700" 
                                fill="#374151"
                            >
                                {tile.token}
                            </text>
                        </g>
                    )}
                </g>
            );
        }

        // Mobile Tile Editor
        function MobileTileEditor({ tile, tileIndex, onUpdate, onClose }) {
            const resourceIcons = {
                wood: "üå≤", brick: "üß±", sheep: "üêë", 
                wheat: "üåæ", ore: "‚öíÔ∏è", desert: "üèúÔ∏è"
            };

            return (
                <div>
                    <div className="flex items-center justify-between mb-3">
                        <h3 className="font-semibold text-gray-900">Edit Tile {tileIndex}</h3>
                        <button 
                            onClick={onClose}
                            className="text-gray-400 hover:text-gray-600"
                        >
                            ‚úï
                        </button>
                    </div>
                    
                    <div className="space-y-3">
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">Resource</label>
                            <select 
                                value={tile.resource}
                                onChange={(e) => onUpdate({ 
                                    resource: e.target.value,
                                    token: e.target.value === 'desert' ? null : tile.token
                                })}
                                className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm"
                            >
                                {Object.entries(resourceIcons).map(([resource, icon]) => (
                                    <option key={resource} value={resource}>
                                        {icon} {resource.charAt(0).toUpperCase() + resource.slice(1)}
                                    </option>
                                ))}
                            </select>
                        </div>

                        {tile.resource !== 'desert' && (
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">Number Token</label>
                                <select 
                                    value={tile.token || ''}
                                    onChange={(e) => onUpdate({ token: e.target.value ? Number(e.target.value) : null })}
                                    className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm"
                                >
                                    <option value="">No Token</option>
                                    {[2,3,4,5,6,8,9,10,11,12].map(num => (
                                        <option key={num} value={num}>
                                            {num} {num === 6 || num === 8 ? 'üî•' : ''}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Mobile Prediction Results
        function MobilePredictionResults({ results, showAdvanced }) {
            if (!results || !results.playerStats) {
                return (
                    <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-sm">
                        ‚ùå Invalid prediction results
                    </div>
                );
            }

            return (
                <div className="slide-in bg-white rounded-lg shadow-sm p-4">
                    <h2 className="text-lg font-bold text-gray-900 mb-4">üéØ Prediction Results</h2>
                    
                    {/* Player Results Grid */}
                    <div className="grid grid-cols-2 gap-3 mb-4">
                        {results.playerStats.map((stats, index) => (
                            <div key={index} className="bg-gray-50 rounded-lg p-3">
                                <div className="flex items-center mb-2">
                                    <div 
                                        className="w-3 h-3 rounded-full mr-2" 
                                        style={{backgroundColor: PLAYER_COLORS[index]}}
                                    />
                                    <span className="font-medium text-sm">Player {index + 1}</span>
                                </div>
                                
                                <div className="text-xl font-bold text-green-600 mb-1">
                                    {stats.winPercentage.toFixed(1)}%
                                </div>
                                <div className="text-xs text-gray-600">
                                    {stats.wins} / {results.totalGames} wins
                                </div>
                                
                                {showAdvanced && (
                                    <div className="mt-2 text-xs text-gray-500 space-y-1">
                                        <div>Avg VP: {stats.averageVP.toFixed(1)}</div>
                                        <div>Ports: {stats.portAdvantage.totalPorts}</div>
                                        <div>Trade: {(stats.tradingEfficiency * 100).toFixed(0)}%</div>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>

                    {/* Summary Stats */}
                    <div className="bg-gray-50 rounded-lg p-3">
                        <div className="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Most Likely Winner:</span>
                                <div className="font-medium" style={{color: PLAYER_COLORS[results.wins.indexOf(Math.max(...results.wins))]}}>
                                    Player {results.wins.indexOf(Math.max(...results.wins)) + 1}
                                </div>
                            </div>
                            <div>
                                <span className="text-gray-600">Avg Game Length:</span>
                                <div className="font-medium">{results.averageGameLength.toFixed(0)} turns</div>
                            </div>
                        </div>
                    </div>

                    {showAdvanced && (
                        <div className="mt-4 text-xs text-gray-500">
                            <div>‚úÖ Simulation completed with trading system integration</div>
                            <div>üè™ Port advantages calculated for all players</div>
                            <div>üìä Advanced analytics available in detailed view</div>
                        </div>
                    )}
                </div>
            );
        }

        // Mobile Board Stats
        function MobileBoardStats({ boardSetup }) {
            const resourceCounts = RESOURCES.reduce((acc, resource) => {
                acc[resource] = boardSetup.tiles.filter(tile => tile.resource === resource).length;
                return acc;
            }, { desert: boardSetup.tiles.filter(tile => tile.resource === 'desert').length });

            const tokenCounts = {};
            boardSetup.tiles.forEach(tile => {
                if (tile.token) {
                    tokenCounts[tile.token] = (tokenCounts[tile.token] || 0) + 1;
                }
            });

            const isValidBoard = boardSetup.tiles.length === 19 && resourceCounts.desert === 1;

            return (
                <div className="space-y-3">
                    <div className={`p-2 rounded text-sm ${isValidBoard ? 'bg-green-50 text-green-700' : 'bg-red-50 text-red-700'}`}>
                        {isValidBoard ? '‚úÖ Valid Catan Board' : '‚ùå Invalid Board Layout'}
                    </div>
                    
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <h4 className="font-medium text-gray-700 mb-2 text-sm">Resources</h4>
                            <div className="space-y-1">
                                {Object.entries(resourceCounts).map(([resource, count]) => (
                                    <div key={resource} className="flex justify-between text-xs">
                                        <span className="capitalize">{resource}</span>
                                        <span className={count === 0 ? 'text-red-500' : 'text-gray-700'}>{count}</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-medium text-gray-700 mb-2 text-sm">Hot Numbers</h4>
                            <div className="space-y-1">
                                {[6, 8].map(num => (
                                    <div key={num} className="flex justify-between text-xs">
                                        <span>{num} (Hot)</span>
                                        <span className="text-red-600 font-medium">{tokenCounts[num] || 0}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Mobile Trading Analysis
        function MobileTradingAnalysis({ results }) {
            return (
                <div className="space-y-3">
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <h4 className="font-medium text-gray-700 mb-2 text-sm">Port Distribution</h4>
                            <div className="space-y-1">
                                {results.tradingAnalysis.portDistribution.map((ports, index) => (
                                    <div key={index} className="flex justify-between text-xs">
                                        <span>Player {index + 1}</span>
                                        <span className="font-medium">{ports} ports</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-medium text-gray-700 mb-2 text-sm">Trading Efficiency</h4>
                            <div className="space-y-1">
                                {results.tradingAnalysis.tradingAdvantages.map((efficiency, index) => (
                                    <div key={index} className="flex justify-between text-xs">
                                        <span>Player {index + 1}</span>
                                        <span className="font-medium">{(efficiency * 100).toFixed(0)}%</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="bg-blue-50 p-2 rounded text-xs text-blue-700">
                        <div className="font-medium mb-1">Trading Rules Applied:</div>
                        <div>‚Ä¢ Bank: 4:1 for any resource</div>
                        <div>‚Ä¢ Generic Ports: 3:1 for any resource</div>
                        <div>‚Ä¢ Specialized Ports: 2:1 for specific resource</div>
                    </div>
                </div>
            );
        }

        // Helper function to create random board
        function createRandomBoard() {
            const resources = [
                ...Array(4).fill("wood"),
                ...Array(3).fill("brick"), 
                ...Array(4).fill("sheep"),
                ...Array(4).fill("wheat"),
                ...Array(3).fill("ore"),
                "desert"
            ];
            
            const tokens = [...TOKENS];
            const shuffledResources = [...resources].sort(() => Math.random() - 0.5);
            const shuffledTokens = [...tokens].sort(() => Math.random() - 0.5);
            
            const positions = [
                { x: 300, y: 120 }, { x: 370, y: 120 }, { x: 440, y: 120 },
                { x: 230, y: 170 }, { x: 300, y: 170 }, { x: 370, y: 170 }, { x: 440, y: 170 },
                { x: 160, y: 220 }, { x: 230, y: 220 }, { x: 300, y: 220 }, { x: 370, y: 220 }, { x: 440, y: 220 },
                { x: 160, y: 270 }, { x: 230, y: 270 }, { x: 300, y: 270 }, { x: 370, y: 270 },
                { x: 160, y: 320 }, { x: 230, y: 320 }, { x: 300, y: 320 }
            ];
            
            const tiles = positions.map((pos, index) => {
                const resource = shuffledResources[index];
                const token = resource === 'desert' ? null : shuffledTokens.pop();
                return { ...pos, resource, token };
            });
            
            return { tiles };
        }

        // Mount the mobile app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MobileCatanPredictor />);
    </script>
</body>
</html>